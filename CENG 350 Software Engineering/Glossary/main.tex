\documentclass{article}
\usepackage[utf8]{inputenc}
\title{Glossary of Terms for CENG350}
\begin{document}
\maketitle

\section*{Glossary}
\subsection{Chapter 1}
\begin{description}
  \item[Software] Instructions (programs) that provide desired features, functions, and performance; data structures that enable programs to manipulate information; and documentation that describes the operation and use of programs.
  
  \item[System Software] Software designed to provide a platform for other software. Examples include operating systems and utility software.
  
  \item[Application Software] Software designed to help the user perform specific tasks. Examples include word processors, spreadsheets, and media players.
  
  \item[Engineering/Scientific Software] Software used for scientific research and engineering applications, such as simulation software and scientific calculators.
  
  \item[Embedded Software] Software written to control machines or devices that are not typically considered computers. Examples include software for automotive systems and industrial machines.
  
  \item[Product-line Software] Software developed to be used in a family of products. Examples include software components shared across a range of products from a single company.
  
  \item[Web Applications (WebApps)] Software that runs on web servers and can be accessed through web browsers.
  
  \item[AI Software] Software that enables computers to perform tasks that typically require human intelligence, such as visual perception, speech recognition, and decision-making.
  
  \item[Open World Computing] Pervasive, distributed computing environments.
  
  \item[Ubiquitous Computing] Computing that is available anytime and anywhere through wireless networks.
  
  \item[Netsourcing] Using the web as a computing engine.
  
  \item[Open Source Software] Software with source code that is available for anyone to use, modify, and distribute.
  
  \item[Data Mining] The process of discovering patterns and knowledge from large amounts of data.
  
  \item[Grid Computing] Using a network of computers to work together to solve complex problems.
  
  \item[Cognitive Machines] Machines that can mimic human cognitive functions such as learning and problem-solving.
  
  \item[Legacy Software] Existing software that must be adapted, enhanced, extended, or re-architected to remain useful.
  
  \item[Concurrency] The ability of a system to handle multiple tasks simultaneously.
  
  \item[Process Model] A representation of the process used to develop software.
  
  \item[Quality Assurance (QA)] Activities designed to ensure that the software meets certain standards of quality.
  
  \item[Configuration Management] The process of managing changes to software to maintain its integrity over time.
  
  \item[Risk Management] The process of identifying, assessing, and prioritizing risks, and then taking steps to minimize their impact.
\end{description}

\subsection{Chapter 2 }
\begin{description}
  \item[Software Process] A structured set of activities required to develop a software system, including specification, design, implementation, validation, and evolution.
  
  \item[Specification] The process of defining what a system should do.
  
  \item[Design and Implementation] Defining the organization of a system and converting the specification into an executable system.
  
  \item[Validation] Checking that the system does what the customer wants.
  
  \item[Evolution] Changing the system in response to changing customer needs.
  
  \item[Plan-driven Processes] Processes where all activities are planned in advance and progress is measured against the plan.
  
  \item[Agile Processes] Processes with incremental planning and easier adaptation to changes.
  
  \item[Waterfall Model] A plan-driven software process model with distinct phases of specification and development.
  
  \item[Incremental Development] A process where specification, development, and validation activities are interleaved.
  
  \item[Integration and Configuration] Developing a system by assembling existing configurable components.
  
  \item[Component-based Software Engineering (CBSE)] A method of software development that involves assembling software from existing components.
  
  \item[Requirements Engineering] The process of defining, documenting, and maintaining software requirements.
  
  \item[Verification and Validation (V\&V)] Activities that ensure a system meets its specifications and customer requirements.
  
  \item[System Testing] Testing the system as a whole to ensure it meets its requirements.
  
  \item[Software Evolution] The process of modifying software to adapt to new conditions or correct faults.
  
  \item[Prototyping] Creating an initial version of a system to demonstrate concepts and try out design options.
  
  \item[Incremental Delivery] Delivering a system in increments, each providing part of the required functionality.
  
  \item[Reuse-oriented Software Engineering] Developing software by integrating and configuring existing components or systems.
  
  \item[Change Anticipation] Including activities in the software process that anticipate possible changes.
  
  \item[Change Tolerance] Designing the process to accommodate changes at a relatively low cost.
\end{description}

\subsection{Leloudas Chapter 2}

\begin{description}
  \item[Dynamic Testing] Testing that involves executing the code with test cases.
  \item[Static Testing] Testing that involves checking the code and documents without executing the code.
  \item[Unit Testing] Testing individual components.
  \item[Integration Testing] Testing combined parts of an application to ensure they work together.
  \item[System Testing] Testing the complete integrated system.
  \item[Acceptance Testing] Testing the system’s compliance with the business requirements.
  \item[Black-box Testing] Testing without knowledge of the internal workings of the application.
  \item[White-box Testing] Testing with knowledge of the internal workings of the application.
\end{description}

\subsection{Chapter 3}

\begin{description}
  \item[Agile Development] An approach to software development with interleaved specification, design, and implementation, focusing on rapid delivery, minimal documentation, and frequent releases.
  
  \item[Plan-driven Development] A structured approach to software engineering with separate development stages and planned outputs for each stage.
  
  \item[Extreme Programming (XP)] An agile method emphasizing customer satisfaction, frequent releases, continuous testing, and collaboration.
  
  \item[Incremental Delivery] Delivering software in small, usable increments, allowing for frequent customer feedback and adjustments.
  
  \item[Customer Involvement] Engaging customers throughout the development process to provide and prioritize requirements and evaluate iterations.
  
  \item[Refactoring] The process of restructuring existing code without changing its external behavior to improve readability and reduce complexity.
  
  \item[Test-first Development] Writing tests before the actual code to clarify requirements and ensure functionality from the beginning.
  
  \item[Pair Programming] Two programmers working together at one workstation, collaborating on code development and review.
  
  \item[Continuous Integration] Integrating and testing code frequently to catch issues early and ensure ongoing functionality.
  
  \item[Scrum] An agile framework for managing iterative development, with roles such as Product Owner and ScrumMaster, and events like sprints and daily scrums.
  
  \item[Agile Manifesto] A declaration of the core values and principles of agile software development, emphasizing individuals, working software, customer collaboration, and response to change.
  
  \item[Scaling Agile] Adapting agile methods to handle large, complex projects and distributed teams while maintaining core agile principles.
  
  \item[Sustainable Pace] Ensuring that the development team works at a pace that can be maintained indefinitely without burnout.
  
  \item[User Stories] Simple descriptions of a software feature from an end-user perspective, used in agile development to capture requirements.
  
  \item[Automated Testing] Using software tools to run tests on code automatically, ensuring consistency and reducing manual testing effort.
  
  \item[Incremental Planning] Planning software development in small, manageable increments rather than a single, detailed upfront plan.
  
  \item[Simple Design] Focusing on designing only what is necessary for current requirements, avoiding over-engineering.
\end{description}


\subsection{Chapter 4}

\begin{description}
  \item[Requirements Engineering] The process of establishing the services a customer requires from a system and the constraints under which it operates and is developed.
  
  \item[User Requirements] Statements in natural language plus diagrams of the services the system provides and its operational constraints.
  
  \item[System Requirements] A structured document setting out detailed descriptions of the system’s functions, services, and operational constraints.
  
  \item[Functional Requirements] Statements of services the system should provide, how the system should react to particular inputs, and how the system should behave in particular situations.
  
  \item[Non-functional Requirements] Constraints on the services or functions offered by the system such as timing constraints, constraints on the development process, and quality requirements (e.g., usability, performance).
  
  \item[System Stakeholders] Individuals or organizations affected by the system in some way and who have a legitimate interest.
  
  \item[Requirements Elicitation] The process of working with stakeholders to find out about the application domain, the services that the system should provide, and the system’s operational constraints.
  
  \item[Requirements Specification] The process of writing down the user and system requirements in a requirements document.
  
  \item[Requirements Validation] The process of demonstrating that the requirements define the system that the customer really wants. It involves checks for validity, consistency, completeness, realism, and verifiability.
  
  \item[Requirements Management] The process of managing changing requirements during the requirements engineering process and system development.
  
  \item[Requirements Document] The official statement of what is required of the system developers. It includes both user and system requirements.
  
  \item[Requirements Change Management] The process of deciding if a requirements change should be accepted, analyzing the change, and implementing it.
  
  \item[Requirements Review] A systematic manual analysis of the requirements to ensure they meet the necessary criteria.
  
  \item[Ethnography] A social science research method that involves observing and analyzing how people actually work to derive requirements.
  
  \item[Use Cases] Scenarios that identify the actors in an interaction and describe the interaction itself.
  
  \item[Prototype] An initial version of a system used to demonstrate concepts and try out design options.
  
  \item[Domain Requirements] Constraints on the system from the domain of operation, such as legal or regulatory constraints.
  
  \item[Spiral Model] An iterative model of the requirements engineering process that includes cycles of requirements discovery, classification, negotiation, and documentation.
\end{description}

\subsection{Chapter 5: System Modeling}

\begin{description}
  \item[System Modeling] The process of developing abstract models of a system to present different views or perspectives.
  \item[Unified Modeling Language (UML)] A standardized modeling language used to specify, visualize, construct, and document the artifacts of software systems.
  \item[Context Models] Models that illustrate the operational context of a system and show what lies outside its boundaries.
  \item[Interaction Models] Models that highlight the interactions between a system and its environment or between system components.
  \item[Structural Models] Models that display the organization of a system in terms of its components and their relationships.
  \item[Behavioral Models] Models that show the dynamic behavior of a system and how it responds to events.
  \item[Activity Diagrams] UML diagrams that show the activities involved in a process or data processing.
  \item[Use Case Diagrams] UML diagrams that show the interactions between a system and its environment.
  \item[Sequence Diagrams] UML diagrams that show interactions between actors and the system or between system components.
  \item[Class Diagrams] UML diagrams that show the object classes in a system and the associations between these classes.
  \item[State Diagrams] UML diagrams that show how the system reacts to internal and external events.
  \item[Model-driven Engineering (MDE)] An approach to software development where models are the principal outputs, and programs are generated from these models.
\end{description}

\subsection{Leloudas Chapter 5}

\begin{description}
  \item[Test Design Techniques] Techniques for designing effective test cases.
  \item[Equivalence Partitioning] Dividing input data into partitions and testing one value from each.
  \item[Boundary Value Analysis] Testing at the boundaries between partitions.
  \item[Decision Table Testing] Using decision tables to represent combinations of inputs and outputs.
  \item[State Transition Testing] Testing state changes in the application.
\end{description}
\subsection{Chapter 6: Architectural Design}

\begin{description}
  \item[Architectural Design] The process of defining a structured solution that meets all the technical and operational requirements.
  \item[4+1 View Model] A model of software architecture describing logical view, process view, development view, physical view, and scenarios.
  \item[Model-View-Controller (MVC)] An architectural pattern that separates an application into three main components: Model, View, and Controller.
  \item[Layered Architecture] Organizes the system into layers with related functionality, where each layer provides services to the layer above it.
  \item[Repository Pattern] Manages all data in a system in a central repository accessible to all system components.
  \item[Client-Server] An architecture where services are provided by servers and accessed by clients over a network.
  \item[Pipe and Filter] An architecture where data processing components (filters) are connected in a sequence (pipes) to process data.
  \item[Transaction Processing Systems] Interactive systems that allow information in a database to be remotely accessed and modified by multiple users.
  \item[Language Processing Systems] Systems used to translate texts from one language to another or carry out instructions specified in an input language.
  \item[Architectural Patterns] Stylized descriptions of good design practices.
  \item[Application Architectures] Generic architectures for different types of software systems.
\end{description}

\subsection{Chapter 7: Design and Implementation}

\begin{description}
  \item[Design and Implementation] The stages in the software engineering process where an executable software system is developed, involving design activities and realizing the design as a program.
  \item[Object-oriented Design] A design method where a system is viewed as a collection of interacting objects, each with a defined role and responsibility.
  \item[Design Patterns] Reusable solutions to common software design problems.
  \item[Singleton Pattern] A design pattern that restricts the instantiation of a class to one object.
  \item[Factory Pattern] A design pattern that provides an interface for creating objects, allowing subclasses to alter the type of objects that will be created.
  \item[Observer Pattern] A design pattern where an object maintains a list of dependents and notifies them of state changes.
  \item[Open Source Development] A software development model where the source code is made publicly available for use, modification, and distribution.
  \item[Error Handling] The process of responding to and managing errors that occur in a software system.
  \item[Optimizing for Performance] Techniques used to improve the efficiency and speed of a software system.
  \item[Managing Dependencies] The process of handling the interdependencies between software components.
\end{description}
\subsection{Chapter 8: Software Testing}

\begin{description}
  \item[Software Testing] The process of executing a program with the intent of finding errors and ensuring that the software functions as intended.
  \item[Validation Testing] Testing to demonstrate that the software meets its requirements.
  \item[Defect Testing] Testing to discover faults or defects in the software.
  \item[Development Testing] Testing carried out by the development team during development.
  \item[Release Testing] Testing a complete version of the system before release.
  \item[User Testing] Testing by users or potential users in their own environment.
  \item[Unit Testing] Testing individual components in isolation to ensure they function correctly.
  \item[Automated Testing] Using test automation frameworks to write and run tests without manual intervention.
  \item[System Testing] Integrating components and testing the system against its requirements.
  \item[Alpha Testing] Users work with the development team to test the software.
  \item[Beta Testing] Software is released to users to experiment and report problems.
  \item[Acceptance Testing] Customers test the system to decide whether it is ready for deployment.
  \item[Test-driven Development (TDD)] Writing tests before code and using tests to drive development.
  \item[Code Coverage] Ensuring that all code written has at least one associated test.
  \item[Regression Testing] Testing the system to check that changes have not broken previously working code.
  \item[Verification] Checking that the software conforms to its specification.
  \item[Validation] Checking that the software does what the user requires.
\end{description}

\subsection{Chapter 9: Software Evolution}

\begin{description}
  \item[Software Evolution] The process of developing, maintaining, and updating software systems over time.
  \item[Corrective Maintenance] Fixing defects in the software.
  \item[Adaptive Maintenance] Modifying the software to work in a new or changed environment.
  \item[Perfective Maintenance] Enhancing the software to improve performance or maintainability.
  \item[Preventive Maintenance] Making changes to prevent future problems.
  \item[Legacy Systems] Older software systems that remain critical to an organization.
  \item[Phase-out] The stage where the software is still used but no further changes are made.
  \item[Servicing] Changes made only to keep the software operational.
  \item[Software Maintenance] The process of modifying a software system after it has been delivered.
\end{description}

\subsection{Chapter 10: Dependable Systems}

\begin{description}
  \item[Dependable Systems] Systems that are reliable, available, secure, and safe, reflecting the user’s degree of trust in the system.
  \item[Availability] The probability that the system will be operational and deliver useful services.
  \item[Reliability] The probability that the system will correctly deliver services as expected.
  \item[Safety] The likelihood that the system will not cause harm to people or the environment.
  \item[Security] The likelihood that the system can resist accidental or deliberate intrusions.
  \item[Resilience] The ability of the system to maintain continuity of critical services in the presence of disruptive events.
  \item[Redundancy] Keeping multiple versions of critical components to ensure availability in case of failure.
  \item[Diversity] Providing the same functionality in different ways to avoid common-mode failures.
  \item[Sociotechnical Systems] Systems that include hardware, software, and people, situated within an organization.
  \item[Formal Methods] Approaches to software development based on mathematical representation and analysis of software.
\end{description}

\subsection{Chapter 13: Security Engineering}

\begin{description}
  \item[Confidentiality] Ensuring that information is not accessed by unauthorized persons.
  \item[Integrity] Ensuring that information is not altered by unauthorized persons.
  \item[Availability] Ensuring that information is accessible to authorized users when needed.
  \item[Privacy] Ensuring the confidentiality of personal data.
  \item[Authentication] Verifying the identity of users or systems.
  \item[Authorization] Granting permissions to users or systems.
  \item[Non-repudiation] Ensuring that actions or transactions cannot be denied.
  \item[Infrastructure Security] Security of the systems and networks providing infrastructure services.
  \item[Application Security] Security of individual application systems.
  \item[Operational Security] Secure operation and use of systems within an organization.
  \item[Interception] Gaining unauthorized access to an asset.
  \item[Interruption] Making a system or part of a system unavailable.
  \item[Modification] Tampering with a system asset.
  \item[Fabrication] Inserting false information into a system.
\end{description}
\subsection{Chapter 24: Quality Management}

\begin{description}
  \item[Software Quality Management] Ensuring that the required level of quality is achieved in a software product.
  \item[Quality Planning] Setting out the desired product qualities, how these are assessed, and defining the standards to be used.
  \item[Software Quality Attributes] Attributes such as safety, security, reliability, and resilience that determine software quality.
  \item[Process Standards] Standards that define the processes to be followed during software development.
  \item[Product Standards] Standards that apply to the software product being developed.
  \item[Quality Culture] A culture where all team members are committed to achieving a high level of product quality.
  \item[ISO 9001] An international set of standards for developing quality management systems.
  \item[Software Metrics] Quantitative measurements used to assess software processes and products.
  \item[Empirical Software Engineering] Research area using data from software projects to form and validate hypotheses about software engineering methods and techniques.
\end{description}

\subsection{ACM Code of Ethics and Professional Conduct}

\begin{description}
  \item[Contribute to Society] The obligation to use skills for the benefit of society and its members.
  \item[Avoid Harm] Taking actions to minimize negative consequences.
  \item[Honesty] Being transparent and providing full disclosure.
  \item[Fairness] Ensuring equality, tolerance, and justice.
  \item[Respect Privacy] Protecting personal data and ensuring informed consent.
  \item[Honor Confidentiality] Protecting sensitive information unless disclosure is legally or ethically justified.
  \item[Professional Competence] Maintaining technical knowledge and skills.
  \item[Ethical Practice] Adhering to ethical standards and principles in professional work.
  \item[Public Awareness] Educating the public about computing technologies and their impacts.
  \item[Robust Security] Designing and implementing systems to prevent unauthorized access and misuse.
  \item[Public Good] Prioritizing the welfare of society in all professional activities.
  \item[Social Responsibilities] Ensuring organizational policies align with ethical principles.
\end{description}

\subsection{The Scrum Guide}

\begin{description}
  \item[Scrum] A lightweight framework for generating value through adaptive solutions for complex problems.
  \item[Empiricism] Making decisions based on what is observed.
  \item[Lean Thinking] Reducing waste and focusing on essentials.
  \item[Commitment] Dedicating oneself to achieving goals and supporting the team.
  \item[Focus] Concentrating on the work of the Sprint to make the best possible progress.
  \item[Openness] Being transparent about the work and challenges.
  \item[Respect] Valuing each team member's capabilities and independence.
  \item[Courage] Facing tough problems and doing the right thing.
  \item[Scrum Team] A small team consisting of a Scrum Master, a Product Owner, and Developers.
  \item[Sprint] A fixed-length event of one month or less to create consistency.
  \item[Product Backlog] An ordered list of what is needed to improve the product.
  \item[Sprint Backlog] The set of Product Backlog items selected for the Sprint and the plan for delivering them.
  \item[Increment] A concrete stepping stone toward the Product Goal.
  \item[Definition of Done] A formal description of the state of the Increment when it meets the quality measures required for the product.
\end{description}


\subsection{WIPO Understanding Copyrights}

\begin{description}
  \item[Copyright] A legal right that grants creators exclusive rights to their original works.
  \item[Economic Rights] Rights to reproduce, distribute, and publicly perform a work.
  \item[Moral Rights] Rights to claim authorship and oppose harmful modifications.
  \item[Limitations and Exceptions] Permitted uses of copyrighted works without authorization.
  \item[Duration of Protection] The period during which copyright protection is in effect, usually the life of the author plus a number of years.
\end{description}

\subsection{WIPO Understanding Industrial Property}

\begin{description}
  \item[Industrial Property] Includes patents, trademarks, industrial designs, and geographical indications.
  \item[Patent] A legal right granted for an invention, giving the inventor exclusive rights for a limited period.
  \item[Trademark] A sign that distinguishes the goods or services of one enterprise from those of others.
  \item[Industrial Design] Protects the ornamental or aesthetic aspects of an article.
  \item[Geographical Indication] Indicates that a product originates from a specific place and has qualities or a reputation due to that origin.
\end{description}



\end{document}
